<!doctype html>
<html dir="ltr" lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Rails Websockets — Ruby on Rails Guides</title>
    <link rel="stylesheet" type="text/css" href="stylesheets/style.css" data-turbo-track="reload">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">
    <link rel="stylesheet" type="text/css" href="stylesheets/highlight.css" data-turbo-track="reload">
    <link rel="icon" href="images/backend-development.svg" sizes="any">
    <script src="javascripts/@hotwired--turbo.js" data-turbo-track="reload"></script>
    <script src="javascripts/clipboard.js" data-turbo-track="reload"></script>
    <script src="javascripts/guides.js" data-turbo-track="reload"></script>
    <meta property="og:title" content="Rails Websockets — Ruby on Rails Guides" />
    <meta name="description" content="Rails WebsocketsWhile HTTP only allows requests from the client sent to the server, websockets offer a permanent connection between client and server. With Actioncable you can use websockets for publish-subscribe communication.By referring to this guide, you will be able to: Build a chat app in your webapp Incorporate &quot;server push&quot; functionality in your app You can study the code and try out the demo for the example app described here." />
    <meta property="og:description" content="Rails WebsocketsWhile HTTP only allows requests from the client sent to the server, websockets offer a permanent connection between client and server. With Actioncable you can use websockets for publish-subscribe communication.By referring to this guide, you will be able to: Build a chat app in your webapp Incorporate &quot;server push&quot; functionality in your app You can study the code and try out the demo for the example app described here." />
    <meta property="og:locale" content="en_US" />
    <meta property="og:site_name" content="Textbook Backend Developemnt" />
    <meta property="og:image" content="images/backend-development.svg" />
    <meta property="og:type" content="website" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Arabic:wght@100..900&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@100..900&family=Noto+Sans+Arabic:wght@100..900&display=swap" rel="stylesheet">
    <meta name="theme-color" content="#2e56e9">
  </head>
  <body class="guide">
    <header id="page_header">
      <div class="wrapper clearfix">
        <nav id="feature_nav">
          <div class="header-logo">
            <a href="/">Backend Development</a>
          </div>
          <ul class="nav">
            <li><a class="nav-item" id="home_nav" href="/">Home</a></li>
            <li class="guides-index guides-index-large">
              <a href="index.html" id="guidesMenu" class="guides-index-item nav-item">Index</a>
              <div id="guides" class="clearfix" style="display: none;">
                <hr />
                <dl class="guides-section-container">
                    <div class="guides-section">
                      <dt>Ruby on Rails</dt>
                        <dd><a href="ruby_commandline.html">Ruby Commandline</a></dd>
                        <dd><a href="rails_database_and_model.html">Models and ActiveRecord</a></dd>
                        <dd><a href="rails_db.html">Database and Migrations</a></dd>
                        <dd><a href="rails_associations_and_validations.html">Associations and Validations</a></dd>
                        <dd><a href="rails_view_and_controller.html">Routing, View and Controller</a></dd>
                        <dd><a href="rails_authentication.html">Simple Authentication</a></dd>
                        <dd><a href="assets_and_import_map.html">The Asset Pipeline and Importmaps</a></dd>
                        <dd><a href="testing.html">Getting started with Testing</a></dd>
                        <dd><a href="refactoring_rails.html">Refactoring Rails</a></dd>
                        <dd><a href="deploy-to-paas.html">Deploy to PAAS</a></dd>
                        <dd><a href="rails_gems.html">Ruby Gems for your Rails Project</a></dd>
                        <dd><a href="deploying_rails.html">Deploying Rails</a></dd>
                    </div>
                    <div class="guides-section">
                      <dt>Ruby on Rails - Advanced Topics</dt>
                        <dd><a href="deploy-to-paas.html">Deploy to PAAS</a></dd>
                        <dd><a href="rest-api.html">REST API</a></dd>
                        <dd><a href="graphql-api.html">GraphQL API</a></dd>
                        <dd><a href="rails_websockets.html">Websocket in Rails</a></dd>
                        <dd><a href="jobs_and_tasks.html">Jobs and Tasks in Rails</a></dd>
                        <dd><a href="rails_security.html">Rails Security</a></dd>
                    </div>
                    <div class="guides-section">
                      <dt>Overarching Concerns</dt>
                        <dd><a href="security.html">Security</a></dd>
                        <dd><a href="adv_authentication.html">Advanced Authentication</a></dd>
                        <dd><a href="caching.html">Caching</a></dd>
                        <dd><a href="advanced_testing.html">Advanced Testing</a></dd>
                        <dd><a href="internationalization.html">Internationalization (I18n)</a></dd>
                        <dd><a href="git_rebasing.html">Git Rebasing</a></dd>
                    </div>
                    <div class="guides-section">
                      <dt>Nodes.js</dt>
                        <dd><a href="node_vs_rails.html">Node vs. Rails</a></dd>
                        <dd><a href="node_basics.html">Node Basics</a></dd>
                        <dd><a href="node_websockets.html">Node Websockets</a></dd>
                        <dd><a href="node_express.html">Node Web App</a></dd>
                        <dd><a href="node_cluster.html">Scaling Node</a></dd>
                    </div>
                    <div class="guides-section">
                      <dt>Next.js</dt>
                        <dd><a href="nextjs.html">Next.js</a></dd>
                    </div>
                </dl>
              </div>
            </li>
            <li class="guides-index guides-index-small">
              <select class="guides-index-item nav-item">
                <option value="index.html">Index</option>
                  <optgroup label="Ruby on Rails">
                      <option value="ruby_commandline.html">Ruby Commandline</option>
                      <option value="rails_database_and_model.html">Models and ActiveRecord</option>
                      <option value="rails_db.html">Database and Migrations</option>
                      <option value="rails_associations_and_validations.html">Associations and Validations</option>
                      <option value="rails_view_and_controller.html">Routing, View and Controller</option>
                      <option value="rails_authentication.html">Simple Authentication</option>
                      <option value="assets_and_import_map.html">The Asset Pipeline and Importmaps</option>
                      <option value="testing.html">Getting started with Testing</option>
                      <option value="refactoring_rails.html">Refactoring Rails</option>
                      <option value="deploy-to-paas.html">Deploy to PAAS</option>
                      <option value="rails_gems.html">Ruby Gems for your Rails Project</option>
                      <option value="deploying_rails.html">Deploying Rails</option>
                  </optgroup>
                  <optgroup label="Ruby on Rails - Advanced Topics">
                      <option value="deploy-to-paas.html">Deploy to PAAS</option>
                      <option value="rest-api.html">REST API</option>
                      <option value="graphql-api.html">GraphQL API</option>
                      <option value="rails_websockets.html">Websocket in Rails</option>
                      <option value="jobs_and_tasks.html">Jobs and Tasks in Rails</option>
                      <option value="rails_security.html">Rails Security</option>
                  </optgroup>
                  <optgroup label="Overarching Concerns">
                      <option value="security.html">Security</option>
                      <option value="adv_authentication.html">Advanced Authentication</option>
                      <option value="caching.html">Caching</option>
                      <option value="advanced_testing.html">Advanced Testing</option>
                      <option value="internationalization.html">Internationalization (I18n)</option>
                      <option value="git_rebasing.html">Git Rebasing</option>
                  </optgroup>
                  <optgroup label="Nodes.js">
                      <option value="node_vs_rails.html">Node vs. Rails</option>
                      <option value="node_basics.html">Node Basics</option>
                      <option value="node_websockets.html">Node Websockets</option>
                      <option value="node_express.html">Node Web App</option>
                      <option value="node_cluster.html">Scaling Node</option>
                  </optgroup>
                  <optgroup label="Next.js">
                      <option value="nextjs.html">Next.js</option>
                  </optgroup>
              </select>
            </li>
          </ul>
        </nav>
      </div>
    </header>
    <hr class="hide" />
    <section id="feature">
      <div class="wrapper">
        <h1>Rails Websockets</h1><p>While HTTP only allows requests from the client sent to the server,
websockets offer a permanent connection between client and server.
With Actioncable you can use websockets for publish-subscribe communication.</p><p>By referring to this guide, you will be able to:</p>
<ul>
<li>Build a chat app in your webapp</li>
<li>Incorporate &quot;server push&quot; functionality in your app</li>
</ul>
<div class="interstitial repo"><p>You can study the <a href="https://github.com/backend-development/rails_websockets">code</a> and try out <a href="https://stepstones.herokuapp.com/">the demo</a> for the example app described here.</p></div>
                  <nav id="subCol">
            <h3 class="chapter">
              <picture>
                <!-- Using the `source`  HTML tag to set the dark theme image -->
                <source
                  srcset="images/icon_book-close-bookmark-1-wht.svg"
                  media="(prefers-color-scheme: dark)"
                />
                <img src="images/icon_book-close-bookmark-1.svg" alt="Chapter Icon" />
              </picture>
              Chapters
            </h3>
            <ol class="chapters">
<li><a href="#websockets">Websockets</a></li>
<li><a href="#publish-subscribe">Publish-Subscribe</a></li>
<li><a href="#chat-example">Chat Example</a>

<ul>
<li><a href="#client-connects-and-subscribes">Client connects and subscribes</a></li>
<li><a href="#server-accepts-and-authentication">Server accepts and Authentication</a></li>
<li><a href="#client-sends-data">Client sends data</a></li>
<li><a href="#server-receives-data">Server receives data</a></li>
<li><a href="#chat-example-client-recieves-data">Client recieves data</a></li>
</ul></li>
<li><a href="#progress-example">Progress Example</a>

<ul>
<li><a href="#client-subscribes">Client subscribes</a></li>
<li><a href="#server-accepts">Server accepts</a></li>
<li><a href="#progress-example-client-recieves-data">Client recieves data</a></li>
<li><a href="#server-sends-data-if-status-changes">Server sends data if status changes</a></li>
<li><a href="#client-recieves-data-partial-as-html">Client recieves data: partial as html</a></li>
</ul></li>
<li><a href="#deployment">Deployment</a></li>
<li><a href="#see-also">See Also</a></li>
</ol>

          </nav>

        <hr>
      </div>
    </section>
    <main id="container">
      <div class="wrapper">
        <div id="mainCol">
          <div class='slide'>
<p>TBD</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-0' href='slides_rails_websockets.html#/0'>◻</a></p>
<h2 id="websockets"><a class="anchorlink" href="#websockets"><span>1</span> Websockets</a></h2><p>Websockets are built on top of HTTP and HTTPS:</p>
<ul>
<li>they reuse the default ports 80 and 443</li>
<li>they start out as a normal HTTP request</li>
<li>they reuse cookies</li>
</ul>
<p>but after the initial request, a websocket turns into
a permanent connection between the server and the client.</p><div class="interstitial code">
<pre><code class="highlight plaintext">GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat 
</code></pre>
<button class="clipboard-button" data-clipboard-text="GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13

HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat 
">Copy</button>
</div>
<p>Both the client and the server can send messages across
the websocket at any time.  Both the client and the
server should be able to handle incoming messages at any time.</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-1' href='slides_rails_websockets.html#/1'>◻</a></p>
<h2 id="publish-subscribe"><a class="anchorlink" href="#publish-subscribe"><span>2</span> Publish-Subscribe</a></h2><p>In Rails we have to distinguish three concepts:</p>
<ul>
<li>The websocket <strong>connection</strong> deals with authenticating a user 

<ul>
<li>see <code>app/channels/application_cable/connection.rb</code></li>
<li>see <code>app/assets/javascripts/cabel.js</code></li>
</ul></li>
<li>A <strong>channel</strong> 

<ul>
<li>see <code>app/channels/*_channel.rb</code></li>
<li>see <code>app/assets/javascripts/channels/*.js</code></li>
</ul></li>
<li>A <strong>stream</strong> inside a channel

<ul>
<li>inside each channel streams are identified by a string</li>
</ul></li>
</ul>
<p>In our example app we will be using:</p>
<ul>
<li>a ChatChannel with one stream, 

<ul>
<li>the stream is identified by <code>room: main</code></li>
</ul></li>
<li>an AdventureChannel with one stream per adventure, for example

<ul>
<li>a stream identified by <code>url_path: /adventures/1</code></li>
<li>a stream identified by <code>url_path: /adventures/2</code></li>
<li>a stream identified by <code>url_path: /adventures/3</code></li>
</ul></li>
</ul>
</div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-2' href='slides_rails_websockets.html#/2'>◻</a></p>
<h2 id="chat-example"><a class="anchorlink" href="#chat-example"><span>3</span> Chat Example</a></h2><p>In our example app several users should be able to chat with each other,
no matter which page of the app they are currently viewing.</p><p><img src="images/chat-screenshot-annotated.png" alt="Screenshot of the Chat Area on the Homepage"></p><p>We will build the app starting from the client side:</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-3' href='slides_rails_websockets.html#/3'>◻</a></p>
<h3 id="client-connects-and-subscribes"><a class="anchorlink" href="#client-connects-and-subscribes"><span>3.1</span> Client connects and subscribes</a></h3><p>The javascript concerning websockets is stored in the
file <code>app/assets/javascripts/cabel.js</code> which was created
by rails. It should look like this:</p><div class="interstitial code">
<pre><code class="highlight javascript"><span class="c1">//= require action_cable</span>
<span class="c1">//= require_self</span>
<span class="c1">//= require_tree ./channels</span>

<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">App</span> <span class="o">||</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">App</span> <span class="o">=</span> <span class="p">{});</span>

  <span class="nx">App</span><span class="p">.</span><span class="nx">cable</span> <span class="o">=</span> <span class="nx">ActionCable</span><span class="p">.</span><span class="nf">createConsumer</span><span class="p">();</span>
<span class="p">}).</span><span class="nf">call</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="//= require action_cable
//= require_self
//= require_tree ./channels

(function() {
  this.App || (this.App = {});

  App.cable = ActionCable.createConsumer();
}).call(this);
">Copy</button>
</div>
<p>and which in turn includes the folder <code>app/assets/javascripts/channels</code>
where we will store our own javascript.  </p><p>To connect each user to the chat channel, we add a new file
<code>app/assets/javascripts/channels/chat.js</code>:</p><div class="interstitial code">
<pre><code class="highlight javascript"><span class="nx">App</span><span class="p">.</span><span class="nx">chatChannel</span> <span class="o">=</span> <span class="nx">App</span><span class="p">.</span><span class="nx">cable</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
  <span class="na">channel</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ChatChannel</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">room</span><span class="p">:</span> <span class="dl">'</span><span class="s1">main</span><span class="dl">'</span>
<span class="p">}</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="App.chatChannel = App.cable.subscriptions.create({
  channel: 'ChatChannel',
  room: 'main'
}
">Copy</button>
</div>
<p>This Javascript code also depends on one meta-tag being set in the webpage:</p><div class="interstitial code">
<pre><code class="highlight plaintext">&lt;meta name="action-cable-url" content="/cable" /&gt;
</code></pre>
<button class="clipboard-button" data-clipboard-text="<meta name=&quot;action-cable-url&quot; content=&quot;/cable&quot; />
">Copy</button>
</div>
<p>Do not write this by hand, use the rails helper in the
file <code>app/views/layouts/application.html.erb</code>:</p><div class="interstitial code">
<pre><code class="highlight plaintext">&lt;%= action_cable_meta_tag %&gt;
</code></pre>
<button class="clipboard-button" data-clipboard-text="<%= action_cable_meta_tag %>
">Copy</button>
</div>
<p>Now the client tries to connect to the websocket at URL <code>/cable</code>
and then subscribe to the chat channel.
If you open your app in the browser now, you should
see an error in the developer tools console:</p><div class="interstitial code">
<pre><code class="highlight plaintext">WebSocket connection to 'ws://localhost:3000/cable' failed: Error during WebSocket handshake: Unexpected response code: 500
</code></pre>
<button class="clipboard-button" data-clipboard-text="WebSocket connection to 'ws://localhost:3000/cable' failed: Error during WebSocket handshake: Unexpected response code: 500
">Copy</button>
</div>
<p>So the client is trying to connect, but it does not work yet.</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-4' href='slides_rails_websockets.html#/4'>◻</a></p>
<h3 id="server-accepts-and-authentication"><a class="anchorlink" href="#server-accepts-and-authentication"><span>3.2</span> Server accepts and Authentication</a></h3><p>The server side code is stored in the folder <code>app/channels</code>. We first
take a look at <code>app/channels/application_cable/connection.rb</code>, which was
created by rails:</p><div class="interstitial code">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">ApplicationCable</span>
  <span class="k">class</span> <span class="nc">Connection</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Connection</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module ApplicationCable
  class Connection < ActionCable::Connection::Base
  end
end
">Copy</button>
</div>
<p>Remember that the server side code concerning websocket is not
called by a controller.  So even if we already built authentication
into our app, and added code for <code>current_user</code> to <code>application_controller.rb</code>,
the <code>current_user</code> will not be available here in the ApplicationCable.</p><p>But we do have access to cookies in Actioncable:</p><div class="interstitial code">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">ApplicationCable</span>
  <span class="k">class</span> <span class="nc">Connection</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Connection</span><span class="o">::</span><span class="no">Base</span>
    <span class="n">identified_by</span> <span class="ss">:current_user</span>    <span class="c1"># creates a instance variable</span>

    <span class="k">def</span> <span class="nf">connect</span>
      <span class="no">Rails</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="s2">"this is the info I read from the cookie:"</span><span class="p">)</span>
      <span class="no">Rails</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="n">cookies</span><span class="p">.</span><span class="nf">encrypted</span><span class="p">[</span><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">session_options</span><span class="p">[</span><span class="ss">:key</span><span class="p">]])</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">disconnect</span>
      <span class="c1"># Any cleanup work needed when the cable connection is cut.</span>
    <span class="k">end</span>    
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :current_user    # creates a instance variable

    def connect
      Rails.logger.warn(&quot;this is the info I read from the cookie:&quot;)
      Rails.logger.warn(cookies.encrypted[Rails.application.config.session_options[:key]])
      self.current_user = User.find(3)
    end

    def disconnect
      # Any cleanup work needed when the cable connection is cut.
    end    
  end
end
">Copy</button>
</div>
<p>After adding this code the browser should be able to connect to
the websocket.  In Firefox with the extension <strong>Websocket Monitor</strong> you
can see the messages sent across the websocket in a separate tab:</p><p><img src="images/ws_firefox.png" alt="Websocket in Firefox with Extension Websocket Monitor"></p><p>You can see that there is more going on than just the subscription
that we initiated from the client side.</p><p>On the server side you will see the connection in the log file:</p><div class="interstitial code">
<pre><code class="highlight plaintext">Started GET "/cable" for ::1 at 2017-01-25 17:45:09 +0100
Started GET "/cable/" [WebSocket] for ::1 at 2017-01-25 17:45:09 +0100
Successfully upgraded to WebSocket (REQUEST_METHOD: GET, HTTP_CONNECTION: keep-alive, Upgrade, HTTP_UPGRADE: websocket)
this is the info I read from the cookie:
{"session_id"=&gt;"b8ee74d5afe32d5", "_csrf_token"=&gt;"9mBRsEoGnRnkkW6", "user_id"=&gt;"3"}
</code></pre>
<button class="clipboard-button" data-clipboard-text="Started GET &quot;/cable&quot; for ::1 at 2017-01-25 17:45:09 +0100
Started GET &quot;/cable/&quot; [WebSocket] for ::1 at 2017-01-25 17:45:09 +0100
Successfully upgraded to WebSocket (REQUEST_METHOD: GET, HTTP_CONNECTION: keep-alive, Upgrade, HTTP_UPGRADE: websocket)
this is the info I read from the cookie:
{&quot;session_id&quot;=>&quot;b8ee74d5afe32d5&quot;, &quot;_csrf_token&quot;=>&quot;9mBRsEoGnRnkkW6&quot;, &quot;user_id&quot;=>&quot;3&quot;}
">Copy</button>
</div>
<p>We successfully decoded the session data from the encrypted cookie, you can see 
that the <code>user_id</code> is 3 in this case. We can use this to set the <code>current_user</code> correctly:</p><div class="interstitial code">
<pre><code class="highlight ruby"><span class="k">module</span> <span class="nn">ApplicationCable</span>
  <span class="k">class</span> <span class="nc">Connection</span> <span class="o">&lt;</span> <span class="no">ActionCable</span><span class="o">::</span><span class="no">Connection</span><span class="o">::</span><span class="no">Base</span>
    <span class="n">identified_by</span> <span class="ss">:current_user</span>    <span class="c1"># creates a instance variable</span>

    <span class="k">def</span> <span class="nf">connect</span>
      <span class="n">session_from_cookie</span> <span class="o">=</span> <span class="n">cookies</span><span class="p">.</span><span class="nf">encrypted</span><span class="p">[</span><span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">session_options</span><span class="p">[</span><span class="ss">:key</span><span class="p">]]</span>
      <span class="n">user_id</span> <span class="o">=</span> <span class="n">session_from_cookie</span><span class="p">[</span><span class="s1">'user_id'</span><span class="p">]</span>
      <span class="n">reject_unauthorized_connection</span> <span class="k">if</span> <span class="n">user_id</span><span class="p">.</span><span class="nf">nil?</span>
      <span class="nb">self</span><span class="p">.</span><span class="nf">current_user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
      <span class="no">Rails</span><span class="p">.</span><span class="nf">logger</span><span class="p">.</span><span class="nf">warn</span><span class="p">(</span><span class="s2">"connection for user </span><span class="si">#{</span><span class="n">current_user</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
      <span class="n">reject_unauthorized_connection</span> <span class="k">if</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">nil?</span>
    <span class="k">end</span>

    <span class="k">def</span> <span class="nf">disconnect</span>
      <span class="c1"># Any cleanup work needed when the cable connection is cut.</span>
    <span class="k">end</span>    
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="module ApplicationCable
  class Connection < ActionCable::Connection::Base
    identified_by :current_user    # creates a instance variable

    def connect
      session_from_cookie = cookies.encrypted[Rails.application.config.session_options[:key]]
      user_id = session_from_cookie['user_id']
      reject_unauthorized_connection if user_id.nil?
      self.current_user = User.find(user_id)
      Rails.logger.warn(&quot;connection for user #{current_user}&quot;)
      reject_unauthorized_connection if current_user.nil?
    end

    def disconnect
      # Any cleanup work needed when the cable connection is cut.
    end    
  end
end
">Copy</button>
</div>
<p>After this, a user that has logged in to the rails app
is automatically also logged in to the websocket, as you
can see in the log file:</p><div class="interstitial code">
<pre><code class="highlight plaintext">Started GET "/cable" for ::1 at 2017-01-25 17:54:51 +0100
Started GET "/cable/" [WebSocket] for ::1 at 2017-01-25 17:54:51 +0100
Successfully upgraded to WebSocket (REQUEST_METHOD: GET, HTTP_CONNECTION: keep-alive, Upgrade, HTTP_UPGRADE: websocket)
  User Load (0.3ms)  SELECT  "users".* FROM "users" WHERE "users"."id" = $1 LIMIT $2  [["id", 3], ["LIMIT", 1]]
connection for user Brigitte Jellinek
Registered connection (Z2lkOi8vc3RlcHN0b25lcy9Vc2VyLzM)
ChatChannel is transmitting the subscription confirmation
ChatChannel is streaming from chat_main
</code></pre>
<button class="clipboard-button" data-clipboard-text="Started GET &quot;/cable&quot; for ::1 at 2017-01-25 17:54:51 +0100
Started GET &quot;/cable/&quot; [WebSocket] for ::1 at 2017-01-25 17:54:51 +0100
Successfully upgraded to WebSocket (REQUEST_METHOD: GET, HTTP_CONNECTION: keep-alive, Upgrade, HTTP_UPGRADE: websocket)
  User Load (0.3ms)  SELECT  &quot;users&quot;.* FROM &quot;users&quot; WHERE &quot;users&quot;.&quot;id&quot; = $1 LIMIT $2  [[&quot;id&quot;, 3], [&quot;LIMIT&quot;, 1]]
connection for user Brigitte Jellinek
Registered connection (Z2lkOi8vc3RlcHN0b25lcy9Vc2VyLzM)
ChatChannel is transmitting the subscription confirmation
ChatChannel is streaming from chat_main
">Copy</button>
</div>
<p>Now the server is ready to receive data from this client and send data to this client.</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-5' href='slides_rails_websockets.html#/5'>◻</a></p>
<h3 id="client-sends-data"><a class="anchorlink" href="#client-sends-data"><span>3.3</span> Client sends data</a></h3><p>To implement the chat we can use the already existing HTML in application.html.erb:</p><div class="interstitial code">
<pre><code class="highlight plaintext">&lt;section id="chat" class="holder" style="display:none;"&gt;
  &lt;div id="output"&gt;
    &lt;p&gt;Chat...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div id="input"&gt;
    &lt;span&gt;&lt;%= current_user %&gt;: &lt;/span&gt;
    &lt;input name="chat" type="text"&gt;
    &lt;input type="button" value="send"&gt;
  &lt;/div&gt;
&lt;/section&gt;
</code></pre>
<button class="clipboard-button" data-clipboard-text="<section id=&quot;chat&quot; class=&quot;holder&quot; style=&quot;display:none;&quot;>
  <div id=&quot;output&quot;>
    <p>Chat...</p>
  </div>
  <div id=&quot;input&quot;>
    <span><%= current_user %>: </span>
    <input name=&quot;chat&quot; type=&quot;text&quot;>
    <input type=&quot;button&quot; value=&quot;send&quot;>
  </div>
</section>
">Copy</button>
</div>
<p>We just have to make it visible as soon as we have a websocket connection.
We change  <code>app/assets/javascripts/channels/chat.js</code>, adding a second
argument to subscriptions.create: an object that holds a <code>connected</code>-function:</p><div class="interstitial code">
<pre><code class="highlight plaintext">// create(channelName, mixin)
App.chatChannel = App.cable.subscriptions.create({
  channel: 'ChatChannel',
  room: 'main'}, 
  {
    connected: function() {
      $('#chat').show();
    }
  }
);
</code></pre>
<button class="clipboard-button" data-clipboard-text="// create(channelName, mixin)
App.chatChannel = App.cable.subscriptions.create({
  channel: 'ChatChannel',
  room: 'main'}, 
  {
    connected: function() {
      $('#chat').show();
    }
  }
);
">Copy</button>
</div>
<p>If a user types something into the chat-input field and
presses enter or the send button, we want the text to
be sent across the websocket:</p><div class="interstitial code">
<pre><code class="highlight plaintext">$(function() {
  function send_chat() {
    var text = $('#input input[name=chat]').val();
    $('#input input[name=chat]').val('');
    App.chatChannel.send({ body: text });
  }

  $('#input input[name=chat]').on('keypress',function (e) {
    if (e.which == 13 || e.keyCode == 13) {
      send_chat();  
    }
  });

  $('#input input[type=button]').on('click', send_chat);
});
</code></pre>
<button class="clipboard-button" data-clipboard-text="$(function() {
  function send_chat() {
    var text = $('#input input[name=chat]').val();
    $('#input input[name=chat]').val('');
    App.chatChannel.send({ body: text });
  }

  $('#input input[name=chat]').on('keypress',function (e) {
    if (e.which == 13 || e.keyCode == 13) {
      send_chat();  
    }
  });

  $('#input input[type=button]').on('click', send_chat);
});
">Copy</button>
</div>
<p>If you type in 'Hello' and send it, you can see the message
being sent in the websocket tab of firefox developer tools:</p><p><img src="images/ws_firefox_send.png" alt="chat message being sent to the server"></p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-6' href='slides_rails_websockets.html#/6'>◻</a></p>
<h3 id="server-receives-data"><a class="anchorlink" href="#server-receives-data"><span>3.4</span> Server receives data</a></h3><p>Right now the server does not know how to handle the incoming data,
in the log file you will read:</p><div class="interstitial code">
<pre><code class="highlight plaintext">Unable to process ChatChannel#receive({"body"=&gt;"hello"})
</code></pre>
<button class="clipboard-button" data-clipboard-text="Unable to process ChatChannel#receive({&quot;body&quot;=>&quot;hello&quot;})
">Copy</button>
</div>
<p>We implement <code>receive</code> in <code>app/channels/chat_channel.rb</code>:</p><div class="interstitial code">
<pre><code class="highlight plaintext">class ChatChannel &lt; ApplicationCable::Channel
  # Called when the consumer has successfully
  # become a subscriber of this channel.
  def subscribed
    stream_from "chat_#{params[:room]}"
  end

  def receive(data)
    data["user"] = current_user.full_name
    data["time"] = Time.now.strftime('%H:%M')
    ActionCable.server.broadcast("chat_#{params[:room]}", data)
  end
end
</code></pre>
<button class="clipboard-button" data-clipboard-text="class ChatChannel < ApplicationCable::Channel
  # Called when the consumer has successfully
  # become a subscriber of this channel.
  def subscribed
    stream_from &quot;chat_#{params[:room]}&quot;
  end

  def receive(data)
    data[&quot;user&quot;] = current_user.full_name
    data[&quot;time&quot;] = Time.now.strftime('%H:%M')
    ActionCable.server.broadcast(&quot;chat_#{params[:room]}&quot;, data)
  end
end
">Copy</button>
</div>
<p>Here we take the data coming in from the client
and add some more: the name of the current user and
the current time on the server.</p><p>The <code>broadcast</code> method will send the new data to 
all users subscribed to the chat-channel, even
the user who originally sent it.</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-7' href='slides_rails_websockets.html#/7'>◻</a></p>
<h3 id="chat-example-client-recieves-data"><a class="anchorlink" href="#chat-example-client-recieves-data"><span>3.5</span> Client recieves data</a></h3><p>In `<code>app/assets/javascripts/channels/chat.js</code>, where
we made the subscription, we add a function to handle
the received data:</p><div class="interstitial code">
<pre><code class="highlight javascript"><span class="nx">App</span><span class="p">.</span><span class="nx">chatChannel</span> <span class="o">=</span> <span class="nx">App</span><span class="p">.</span><span class="nx">cable</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span>
  <span class="na">channel</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ChatChannel</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">room</span><span class="p">:</span> <span class="dl">'</span><span class="s1">main</span><span class="dl">'</span><span class="p">},</span> 
  <span class="p">{</span>
    <span class="na">received</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
      <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#output</span><span class="dl">"</span><span class="p">).</span><span class="nf">append</span><span class="p">(</span>
        <span class="dl">'</span><span class="s1">&lt;p&gt;</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="dl">'</span><span class="s1">user</span><span class="dl">'</span><span class="p">]</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">: </span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="dl">'</span><span class="s1">body</span><span class="dl">'</span><span class="p">]</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">&lt;/p&gt;</span><span class="dl">'</span>
      <span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">);</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="App.chatChannel = App.cable.subscriptions.create({
  channel: 'ChatChannel',
  room: 'main'}, 
  {
    received: function(data) {
      $(&quot;#output&quot;).append(
        '<p>' + data['user'] + ': ' + data['body'] + '</p>'
      );
    }
  }
);
">Copy</button>
</div>
</div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-8' href='slides_rails_websockets.html#/8'>◻</a></p>
<h2 id="progress-example"><a class="anchorlink" href="#progress-example"><span>4</span> Progress Example</a></h2><p>For the second example the communication structure is a bit more complex:
All the users <em>in one adventure</em> should see each other progress through the steps.</p><p><img src="images/adventures-screenshot-annotated.png" alt="Screenshot of the Adventure Page"></p><p>The page displays the adventure and the three steps it consists of.</p><p>The currently logged in user is 'Brigitte Jellinek'. Her progress is described
at the top of the page (purple box) as "You are currently working on step 2.".
A blue cursor just above step 2 also indicates this.</p><p>At every step we can see the status of all users. For example at the 2nd step,
in the green box, we can see the status of four users. We can see
that Alyssa P. Hacker is blocked.</p><p>Inside the yellow box we find the interface the current user can use to change
their status at step 2.</p><p>We will use websockets to communicate changes to all users.  So if Alyssa changes
her status from blocked to finished, the server will send websocket messages to
all the other users currently viewing the page, and their display will change
accordingly.</p><p>Contrast this to a classic web app built with HTTP requests, where you would
need to reload the page to get the new status. </p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-9' href='slides_rails_websockets.html#/9'>◻</a></p>
<h3 id="client-subscribes"><a class="anchorlink" href="#client-subscribes"><span>4.1</span> Client subscribes</a></h3><p>There is no need to change anything in <code>app/assets/javascripts/cabel.js</code>. We 
add another file to the channels folder <code>app/assets/javascripts/channels/adventure.js</code>:</p><div class="interstitial code">
<pre><code class="highlight plaintext">App.cable.subscriptions.create({ channel: "AdventureChannel" })
</code></pre>
<button class="clipboard-button" data-clipboard-text="App.cable.subscriptions.create({ channel: &quot;AdventureChannel&quot; })
">Copy</button>
</div>
<p>In <code>channels/chat.js</code> we also set a room when creating the subscription,
and we used the same room for all users. This time we want to treat users
who are working on different adventures differently.</p><p>One simple way of doing this is to supply the URL of the current page
as a parameter when creating the subscription:</p><div class="interstitial code">
<pre><code class="highlight plaintext">App.adventureChannel = App.cable.subscriptions.create({
  channel: "AdventureChannel",  
  url_path: document.location.pathname
});
</code></pre>
<button class="clipboard-button" data-clipboard-text="App.adventureChannel = App.cable.subscriptions.create({
  channel: &quot;AdventureChannel&quot;,  
  url_path: document.location.pathname
});
">Copy</button>
</div>
<p>The path is communicated via websocket:</p><p><img src="images/subscribe_adventure.png" alt="Websocket in Firefox with Extension Websocket Monitor"></p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-10' href='slides_rails_websockets.html#/10'>◻</a></p>
<h3 id="server-accepts"><a class="anchorlink" href="#server-accepts"><span>4.2</span> Server accepts</a></h3><p>On the server side we create a new file <code>app/channels/adventure_channel.rb</code>:</p><div class="interstitial code">
<pre><code class="highlight ruby"><span class="k">class</span> <span class="nc">AdventureChannel</span> <span class="o">&lt;</span> <span class="no">ApplicationCable</span><span class="o">::</span><span class="no">Channel</span>

  <span class="k">def</span> <span class="nf">subscribed</span>
    <span class="n">stream_from</span> <span class="s1">'/adventures/4'</span>   <span class="c1"># TODO: read param url_path</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="class AdventureChannel < ApplicationCable::Channel

  def subscribed
    stream_from '/adventures/4'   # TODO: read param url_path
  end

end
">Copy</button>
</div>
<p>We only want to send out messages to users who are viewing on
of the adventure-pages, not to people who are on the homepage or anywhere
else.</p><p>So we analyze the <code>url_path</code> parameter we recive from the client,
and only <code>stream_from</code> if the path fits:</p><div class="interstitial code">
<pre><code class="highlight ruby"><span class="k">def</span> <span class="nf">subscribed</span>
  <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="ss">:url_path</span><span class="p">]</span> <span class="o">=~</span> <span class="sr">%r{^/adventures/</span><span class="se">\d</span><span class="sr">+$}</span>
    <span class="n">stream_from</span> <span class="n">params</span><span class="p">[</span><span class="ss">:url_path</span><span class="p">]</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="def subscribed
  if params[:url_path] =~ %r{^/adventures/\d+$}
    stream_from params[:url_path]
  end
end
">Copy</button>
</div>
</div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-11' href='slides_rails_websockets.html#/11'>◻</a></p>
<h3 id="progress-example-client-recieves-data"><a class="anchorlink" href="#progress-example-client-recieves-data"><span>4.3</span> Client recieves data</a></h3><p>To help with debugging the channel while we are building it,
we will copy over any data recived by the client to the chat window:</p><div class="interstitial code">
<pre><code class="highlight javascript"><span class="nx">App</span><span class="p">.</span><span class="nx">adventureChannel</span> <span class="o">=</span> <span class="nx">App</span><span class="p">.</span><span class="nx">cable</span><span class="p">.</span><span class="nx">subscriptions</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span>
  <span class="na">channel</span><span class="p">:</span> <span class="dl">"</span><span class="s2">AdventureChannel</span><span class="dl">"</span><span class="p">,</span>  
  <span class="na">url_path</span><span class="p">:</span> <span class="nb">document</span><span class="p">.</span><span class="nx">location</span><span class="p">.</span><span class="nx">pathname</span>
<span class="p">},</span>
<span class="p">{</span> 
  <span class="na">received</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#output</span><span class="dl">"</span><span class="p">).</span><span class="nf">append</span><span class="p">(</span><span class="dl">'</span><span class="s1">&lt;p&gt;</span><span class="dl">'</span> <span class="o">+</span> <span class="nx">data</span><span class="p">.</span><span class="nx">description</span> <span class="o">+</span> <span class="dl">'</span><span class="s1">&lt;/p&gt;</span><span class="dl">'</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre>
<button class="clipboard-button" data-clipboard-text="App.adventureChannel = App.cable.subscriptions.create({
  channel: &quot;AdventureChannel&quot;,  
  url_path: document.location.pathname
},
{ 
  received: function(data) {
    $(&quot;#output&quot;).append('<p>' + data.description + '</p>');
  }
});
">Copy</button>
</div>
</div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-12' href='slides_rails_websockets.html#/12'>◻</a></p>
<h3 id="server-sends-data-if-status-changes"><a class="anchorlink" href="#server-sends-data-if-status-changes"><span>4.4</span> Server sends data if status changes</a></h3><p>Every time a user changes their status we want the server
to send out messages.  The model where the status is stored
is <code>Step</code>. ActiveRecord supplies hooks for <a href="https://guides.rubyonrails.org/active_record_callbacks.html#transaction-callbacks">callbacks</a> we can use here:</p><div class="interstitial code">
<pre><code class="highlight plaintext">class Step &lt; ApplicationRecord

  delegate :url_helpers, to: 'Rails.application.routes' 

  after_create_commit :notify_adventure_channel
  after_update_commit :notify_adventure_channel

  def notify_adventure_channel
    ActionCable.server.broadcast(
      url_helpers.adventure_path(stepstone.adventure),
      description: describe_new_state
    )
  end
</code></pre>
<button class="clipboard-button" data-clipboard-text="class Step < ApplicationRecord

  delegate :url_helpers, to: 'Rails.application.routes' 

  after_create_commit :notify_adventure_channel
  after_update_commit :notify_adventure_channel

  def notify_adventure_channel
    ActionCable.server.broadcast(
      url_helpers.adventure_path(stepstone.adventure),
      description: describe_new_state
    )
  end
">Copy</button>
</div>
<p>The <code>ActionCable.server.broadcast</code> methods takes one string argument
for identifying the stream to broadcast on. We used the
path to the adventure page, for example <code>"/adventure/3"</code>. Here
we use a helper to contruct this string, we could also have
done it directly with <code>"/adventure/#{stepstone.adventure_id}"</code>.</p><p>With these pieces in place a change in status should already
appear in the chat window.</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-13' href='slides_rails_websockets.html#/13'>◻</a></p>
<h3 id="client-recieves-data-partial-as-html"><a class="anchorlink" href="#client-recieves-data-partial-as-html"><span>4.5</span> Client recieves data: partial as html</a></h3><p>The display of all the users status involves a lot of html and
additional resources.</p><p><img src="images/adventures-screenshot-show-status.png" alt="partial show_status"></p><p>There is already a separate partial to handle this, it is 
called in the <code>adventures/show.html.erb</code> view repeatedly:</p><div class="interstitial code">
<pre><code class="highlight plaintext">&lt;% @stepstones.each_with_index do |stepstone, i| %&gt;
  &lt;div id="step_&lt;%= i %&gt;"&gt;
    &lt;h2&gt;
      &lt;span class="number"&gt;&lt;%= (i + 1).ordinalize %&gt;.&lt;/span&gt; Step   
    &lt;/h2&gt;
    ...
    &lt;article&gt;
      ....
      &lt;div id="step_&lt;%= i %&gt;_show_status" class="step_show_status"&gt;
        &lt;%= render 'stepstones/show_status', stepstone: stepstone, i: i %&gt;
      &lt;/div&gt;
    &lt;/article&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</code></pre>
<button class="clipboard-button" data-clipboard-text="<% @stepstones.each_with_index do |stepstone, i| %>
  <div id=&quot;step_<%= i %>&quot;>
    </div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-14' href='slides_rails_websockets.html#/14'>◻</a></p>
<h2>
      <span class=&quot;number&quot;><%= (i + 1).ordinalize %>.</span> Step   
    </h2>
    ...
    <article>
      ....
      <div id=&quot;step_<%= i %>_show_status&quot; class=&quot;step_show_status&quot;>
        <%= render 'stepstones/show_status', stepstone: stepstone, i: i %>
      </div>
    </article>
  </div>
<% end %>
">Copy</button>
</div>
<p>We can reuse the <code>stepstones/show_status</code> partial on the server side,
when we send the message to the websocket.  And we can reuse the
<code>div</code> with id <code>step_3</code> on the client side, when we incorpoarte the
recieved html into the page. </p><p>We will add two new keys to the message, which now looks like this:</p><div class="interstitial code">
<pre><code class="highlight plaintext">{
  "description": "Alyssa P. Hacker is now blocked at the 2nd step.", 
  "selector": "#step_1_show_status", 
  "html" : "&lt;div class=\"user blocked\"&gt;&lt;span&gt;&lt;img...&gt; ....&lt;/div&gt;\n"
}
</code></pre>
<button class="clipboard-button" data-clipboard-text="{
  &quot;description&quot;: &quot;Alyssa P. Hacker is now blocked at the 2nd step.&quot;, 
  &quot;selector&quot;: &quot;#step_1_show_status&quot;, 
  &quot;html&quot; : &quot;<div class=\&quot;user blocked\&quot;><span><img...> ....</div>\n&quot;
}
">Copy</button>
</div>
<p>On the server we add another key/value pair to message:</p><div class="interstitial code">
<pre><code class="highlight plaintext">  def notify_adventure_channel
    ActionCable.server.broadcast(
      url_helpers.adventure_path(stepstone.adventure),
      description: describe_new_state,
      selector: "#step_#{i}_show_status",
      html:
        ApplicationController.renderer.render(
          partial: 'stepstones/show_status',
          locals: { stepstone: stepstone, i: i }
        )
    )
  end
</code></pre>
<button class="clipboard-button" data-clipboard-text="  def notify_adventure_channel
    ActionCable.server.broadcast(
      url_helpers.adventure_path(stepstone.adventure),
      description: describe_new_state,
      selector: &quot;#step_#{i}_show_status&quot;,
      html:
        ApplicationController.renderer.render(
          partial: 'stepstones/show_status',
          locals: { stepstone: stepstone, i: i }
        )
    )
  end
">Copy</button>
</div>
<p>on the client we just use jQuery to replace the html inside
the div:</p><div class="interstitial code">
<pre><code class="highlight plaintext">received: function(data) {
  $(data.selector).html(data.html);
  $("#output").append('&lt;p&gt;' + data.description + '&lt;/p&gt;');
}
</code></pre>
<button class="clipboard-button" data-clipboard-text="received: function(data) {
  $(data.selector).html(data.html);
  $(&quot;#output&quot;).append('<p>' + data.description + '</p>');
}
">Copy</button>
</div>
<p>Now the status-display with all the users should work!</p></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-15' href='slides_rails_websockets.html#/15'>◻</a></p>
<h2 id="deployment"><a class="anchorlink" href="#deployment"><span>5</span> Deployment</a></h2></div>
<div class='slide'>
<p class='slide_break_block'><a class='slide_break' id='slide-16' href='slides_rails_websockets.html#/16'>◻</a></p>
<h2 id="see-also"><a class="anchorlink" href="#see-also"><span>6</span> See Also</a></h2>
<ul>
<li><a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a></li>
<li><a href="https://blog.ably.io/rails-5-actioncable-the-good-and-bad-parts-1b56c3b31404#.nhzs3q1qd">O'Riordan(2016) Rails ActionCable — The good and bad parts</a> - a good overview of the uses and limitation of ActionCable</li>
</ul>
</div>
        </div>
      </div>
    </main>
    <hr class="hide" />
    <footer id="page_footer">
      <div class="wrapper">
        <p class="copyright">published under <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/at/deed.de">creative commons by-nc-sa</a> in 2012-2025 by <a href="https://brigitte-jellinek.at">Brigitte Jellinek</a>.
</p>
<p>If you want to contribute: <a href="https://github.com/backend-development/backend-development-textbook/fork">fork the source on github</a>
</p>
<p>Favicon "backend development" by Arkinasi from <a href="https://thenounproject.com/browse/icons/term/backend-development/" target="_blank" title="backend development Icons">Noun Project</a> (CC BY 3.0)</p>

      </div>
    </footer>
  </body>
</html>
